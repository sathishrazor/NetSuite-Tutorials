
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

#define OLED_RESET -1
#define SCREEN_ADDRESS 0x3C
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

bool first_angle = false;
float travelled_rate = 0;
uint32_t loop_timer;

#define GYRO_ADDRESS 0x68

struct IMU
{
    int16_t temperature;

    struct
    {
        int16_t x;
        int16_t y;
        int16_t z;
    } gyro;

    struct
    {
        int16_t x;
        int16_t y;
        int16_t z;
    } accl;
};

struct MOTION
{
    float pitch;
    float roll;
    float yaw;
};

struct IMU mpu;
struct MOTION motion;

const unsigned char epd_bitmap_logo200[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7f, 0xf8, 0x7f, 0xfc, 0x3f, 0xe0, 0x1f, 0xfe, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xfc, 0x7f, 0xfc, 0x3f, 0xf0, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xfc, 0x7f, 0xfc, 0x3f, 0xf0, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xfc, 0x7f, 0xfc, 0x3f, 0xf0, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xfc, 0x7f, 0xfc, 0x3f, 0xf0, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xf7, 0xbc, 0x7f, 0xdc, 0x3b, 0xee, 0x3d, 0xfe, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xf7, 0xbc, 0x77, 0xdc, 0x3b, 0xee, 0x3d, 0xfe, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xf0, 0x3c, 0x70, 0x1c, 0x38, 0x0e, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xf0, 0x3c, 0x70, 0x1c, 0x38, 0x0e, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xfc, 0x70, 0x1c, 0x38, 0x0e, 0x3c, 0x0f, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xfc, 0x70, 0x1c, 0x38, 0x0e, 0x3c, 0x0f, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xfc, 0x70, 0x1c, 0x38, 0x0e, 0x3c, 0x0f, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x70, 0x1c, 0x38, 0x0e, 0x3c, 0x0f, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x70, 0x1c, 0x38, 0x0e, 0x3c, 0x0f, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x70, 0x1c, 0x38, 0x0e, 0x3c, 0x0f, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x80, 0x00, 0x00, 0xf7, 0xf8, 0x70, 0x1c, 0x38, 0x0e, 0x3c, 0x0f, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x80, 0x00, 0x00, 0xf0, 0x00, 0x70, 0x1c, 0x38, 0x0e, 0x3c, 0x0f, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x80, 0x00, 0x00, 0xf0, 0x00, 0x70, 0x1c, 0x38, 0x0e, 0x3c, 0x0f, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x80, 0x00, 0x00, 0xf0, 0x00, 0x7f, 0xfc, 0x38, 0x0e, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x80, 0x00, 0x00, 0xf0, 0x00, 0x7f, 0xfc, 0x38, 0x0e, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x80, 0x00, 0x00, 0xf0, 0x00, 0x7f, 0xfc, 0x38, 0x0e, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x80, 0x00, 0x00, 0xf0, 0x00, 0x7f, 0xfc, 0x38, 0x0e, 0x3f, 0xff, 0x00, 0x00, 0x04, 0x00,
    0x0f, 0x80, 0x00, 0x00, 0x60, 0x00, 0x3f, 0xfc, 0x10, 0x04, 0x1f, 0xfe, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x80, 0x00, 0x00, 0x60, 0x00, 0x7f, 0xfc, 0x38, 0x0e, 0x1f, 0xfe, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0xff, 0x30, 0x07, 0xf9, 0xfe, 0x7f, 0xcc, 0xff, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0xff, 0x30, 0x07, 0xf9, 0xfe, 0x7f, 0xcc, 0xff, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0xff, 0x30, 0x07, 0xf9, 0xfe, 0x7f, 0x8c, 0xfe, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0xdf, 0x30, 0x06, 0xd9, 0xbe, 0x7f, 0x8c, 0xdf, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0xa0, 0x00, 0x00, 0xdf, 0x30, 0x06, 0xd9, 0xbe, 0x7f, 0x8c, 0xdf, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x88, 0x00, 0x00, 0xc0, 0x30, 0x07, 0xf9, 0xfe, 0x7f, 0x8c, 0xc0, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0xc0, 0x30, 0x07, 0xf9, 0xfe, 0x7f, 0xcc, 0xc0, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0xc0, 0x30, 0x07, 0xf9, 0xfe, 0x7f, 0xcc, 0xc0, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0xa0, 0x00, 0x00, 0xc0, 0x30, 0x06, 0x18, 0x06, 0x00, 0xcc, 0xc0, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0xc0, 0x30, 0x06, 0xd9, 0xf6, 0x3e, 0xcc, 0xc0, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0xc0, 0x38, 0x06, 0x18, 0x06, 0x00, 0xcc, 0xc0, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0xff, 0x3f, 0xc6, 0x19, 0xfe, 0x7f, 0xcc, 0xff, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0xff, 0x3f, 0xe6, 0x19, 0xfe, 0x7f, 0xcc, 0xff, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0xff, 0x1f, 0xc4, 0x11, 0xfe, 0x3f, 0x88, 0xff, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0x7f, 0x1f, 0xc4, 0x10, 0xfe, 0x3f, 0x88, 0xff, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0x7f, 0x1f, 0xc4, 0x10, 0xfe, 0x3f, 0x88, 0x7e, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

// variables for the position of the ball and paddle
int paddleX = 0;
int paddleY = 0;
int oldPaddleX, oldPaddleY;
int ballDirectionX = 1;
int ballDirectionY = 1;

int ballSpeed = 1; // lower numbers are faster

int ballX, ballY, oldBallX, oldBallY;

int loopCounter = 0;

int x_axis = 0;
int y_axis = 0;

int last_pitch = 0;

int last_roll = 0;

void setup()
{
    Serial.begin(115200);
    delay(200);

    if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS))
    {
        for (;;)
            ; // Don't proceed, loop forever
    }

    mpu6050_initialize();
    delay(200);

    display.clearDisplay();
    display.setTextColor(SSD1306_WHITE);
    display.drawBitmap(0, 0, epd_bitmap_logo200, 128, 96, 1);
    display.display();
    delay(2000);

    // calibrate_gyro();
}

void loop()
{
    // save the width and height of the screen
    loopCounter++;

    update_mpu_values();

    calculateYawPitchRoll();

    // map the paddle's location to the position of the potentiometers
    paddleX = map(motion.pitch, 5, 20, 0, SCREEN_WIDTH) - 20 / 2;
    paddleY = map(95, -100, 100, 0, SCREEN_HEIGHT) - 6 / 2;

    display.drawRect(oldPaddleX, oldPaddleY, 20, 5, SSD1306_WHITE);

    if (oldPaddleX != paddleX || oldPaddleY != paddleY)
    {

        display.drawRect(oldPaddleX, oldPaddleY, 20, 5, SSD1306_WHITE);
        // display.display();
    }

    // draw the paddle on screen, save the current position
    // as the previous.

    display.drawRect(paddleX, paddleY, 20, 5, SSD1306_WHITE);
    // display.display();
    oldPaddleX = paddleX;
    oldPaddleY = paddleY;

    // update the ball's position and draw it on screen
    if (millis() % ballSpeed < 2)
    {
        moveBall();
    }

    while (micros() - loop_timer < 4000)
    {
        // do nothing untill time elapsed

    } // We wait until 4000us are passed.

    if (loopCounter == 50)
    {
        loopCounter = 0;
        Serial.print("P:");
        Serial.print(motion.pitch);
        Serial.print(",");

        Serial.print("R:");
        Serial.println(motion.roll);
    }

    loop_timer = micros();
    display.clearDisplay();
}

// this function determines the ball's position on screen
void moveBall()
{
    // if the ball goes offscreen, reverse the direction:
    if (ballX > display.width() || ballX < 0)
    {
        ballDirectionX = -ballDirectionX;
    }

    if (ballY > display.height() || ballY < 0)
    {
        ballDirectionY = -ballDirectionY;
    }

    // check if the ball and the paddle occupy the same space on screen
    if (inPaddle(ballX, ballY, paddleX, paddleY, 20, 5))
    {
        ballDirectionX = -ballDirectionX;
        ballDirectionY = -ballDirectionY;
    }

    // update the ball's position
    ballX += ballDirectionX;
    ballY += ballDirectionY;

    display.fillCircle(ballX, ballY, 3, SSD1306_WHITE);

    oldBallX = ballX;
    oldBallY = ballY;

    display.display();
}

// this function checks the position of the ball
// to see if it intersects with the paddle
boolean inPaddle(int x, int y, int rectX, int rectY, int rectWidth, int rectHeight)
{
    boolean result = false;

    if ((x >= rectX && x <= (rectX + rectWidth)) && (y >= rectY && y <= (rectY + rectHeight)))
    {
        result = true;
    }

    return result;
}

void calibrate_gyro()
{
    int16_t g_cal_x = 0;
    int16_t g_cal_y = 0;
    int16_t g_cal_z = 0;
    int cal_int = 0;
    display.print("Cal-gyro.");
    for (cal_int = 0; cal_int < 2000; cal_int++)
    { // Take 2000 readings for calibration.
        if (cal_int % 125 == 0)
        {

            display.print("Cal-gyro.");
            display.display();
        }
        update_mpu_values();   // Read the gyro output.
        g_cal_x += mpu.gyro.x; // Read the gyro output.
        g_cal_y += mpu.gyro.y; // Read the gyro output.
        g_cal_z += mpu.gyro.y; // Ad roll value to gyro_roll_cal.

        delay(3); // Wait 3 milliseconds before the next loop.
    }

    g_cal_x /= 2000;
    g_cal_y /= 2000;
    g_cal_z /= 2000;

    Serial.print("g-cal-x:");
    Serial.println(g_cal_x);

    Serial.print("g-cal-y:");
    Serial.println(g_cal_y);

    Serial.print("g-cal-z:");
    Serial.println(g_cal_z);
}

void mpu6050_initialize()
{
    Wire.begin();                         // Start the I2C as master
    Wire.beginTransmission(GYRO_ADDRESS); // Start communication with the MPU-6050.
    Wire.write(0x6B);                     // We want to write to the PWR_MGMT_1 register (6B hex).
    Wire.write(0x00);                     // Set the register bits as 00000000 to activate the gyro.
    Wire.endTransmission();               // End the transmission with the gyro.

    Wire.beginTransmission(GYRO_ADDRESS); // Start communication with the MPU-6050.
    Wire.write(0x1B);                     // We want to write to the GYRO_CONFIG register (1B hex).
    Wire.write(0x08);                     // Set the register bits as 00001000 (500dps full scale).
    Wire.endTransmission();               // End the transmission with the gyro.

    Wire.beginTransmission(GYRO_ADDRESS); // Start communication with the MPU-6050.
    Wire.write(0x1C);                     // We want to write to the ACCEL_CONFIG register (1A hex).
    Wire.write(0x10);                     // Set the register bits as 00010000 (+/- 8g full scale range).
    Wire.endTransmission();               // End the transmission with the gyro.

    Wire.beginTransmission(GYRO_ADDRESS); // Start communication with the MPU-6050.
    Wire.write(0x1A);                     // We want to write to the CONFIG register (1A hex).
    Wire.write(0x03);                     // Set the register bits as 00000011 (Set Digital Low Pass Filter to ~43Hz).
    Wire.endTransmission();
}

// End the transmission with the gyro.
void update_mpu_values()
{
    // Read the MPU-6050 data.
    Wire.beginTransmission(GYRO_ADDRESS); // Start communication with the gyro.
    Wire.write(0x3B);                     // Start reading @ register 43h and auto increment with every read.
    Wire.endTransmission();               // End the transmission.
    Wire.requestFrom(GYRO_ADDRESS, 14);   // Request 14 bytes from the MPU 6050.

    mpu.accl.x = Wire.read() << 8 | Wire.read();      // Add the low and high byte to the acc_x variable.
    mpu.accl.y = Wire.read() << 8 | Wire.read();      // Add the low and high byte to the acc_y variable.
    mpu.accl.z = Wire.read() << 8 | Wire.read();      // Add the low and high byte to the acc_z variable.
    mpu.temperature = Wire.read() << 8 | Wire.read(); // Add the low and high byte to the temperature variable.

    mpu.gyro.x = Wire.read() << 8 | Wire.read(); // Read high and low part of the angular data.
    mpu.gyro.y = Wire.read() << 8 | Wire.read(); // Read high and low part of the angular data.
    mpu.gyro.z = Wire.read() << 8 | Wire.read(); // Read high and low part of the angular data.

    mpu.gyro.y *= -1; // Invert gyro so that nose up gives positive value.
    mpu.gyro.z *= -1; // Invert gyro so that nose right gives positive value.
}

void calculateYawPitchRoll()
{

    // Gyro angle calculations
    // 0.0000611 = 1 / (250Hz / 65.5)
    motion.pitch += mpu.gyro.y * 0.0000611; // Calculate the traveled pitch angle and add this to the angle_pitch variable.
    motion.roll += mpu.gyro.x * 0.0000611;  // Calculate the traveled roll angle and add this to the angle_roll variable.

    // 0.000001066 = 0.0000611 * (3.142(PI) / 180degr) The Arduino sin function is in radians
    // float travelled_rate_rad = travelled_rate * 0.0174555;
    motion.pitch -= motion.roll * sin(mpu.gyro.z * 0.000001066); // If the IMU has yawed transfer the roll angle to the pitch angel.
    motion.roll += motion.pitch * sin(mpu.gyro.z * 0.000001066); // If the IMU has yawed transfer the pitch angle to the roll angel.

    // Accelerometer angle calculations
    if (mpu.accl.x > 4096)
        mpu.accl.x = 4096; // Limit the maximum accelerometer value.
    if (mpu.accl.x < -4096)
        mpu.accl.x = -4096; // Limit the maximum accelerometer value.
    if (mpu.accl.y > 4096)
        mpu.accl.y = 4096; // Limit the maximum accelerometer value.
    if (mpu.accl.y < -4096)
        mpu.accl.y = -4096; // Limit the maximum accelerometer value.

    // 57.296 = 1 / (3.142 / 180) The Arduino asin function is in radians
    float angle_pitch_acc = asin((float)mpu.accl.x / 4096) * 57.296; // Calculate the pitch angle.
    float angle_roll_acc = asin((float)mpu.accl.y / 4096) * 57.296;  // Calculate the roll angle.

    if (!first_angle)
    {                                   // When this is the first time.
        motion.pitch = angle_pitch_acc; // Set the pitch angle to the accelerometer angle.
        motion.roll = angle_roll_acc;   // Set the roll angle to the accelerometer angle.
        first_angle = true;
    }
    else
    {                                                                    // When this is not the first time.
        motion.pitch = motion.pitch * 0.9996 + angle_pitch_acc * 0.0004; // Correct the drift of the gyro pitch angle with the accelerometer pitch angle.
        motion.roll = motion.roll * 0.9996 + angle_roll_acc * 0.0004;    // Correct the drift of the gyro roll angle with the accelerometer roll angle.
    }
}
